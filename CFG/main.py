import heapq

fin = open("data.in", "r")
fout = open("data.out", "w")


def getNonterminals():
    while (fin.readline().strip() != "Nonterminals:"):
        pass

    nonterminals = []

    while 1:
        s = fin.readline()
        if s.split()[0].strip() == "End":
            break
        nonterminals.append(s.strip()[0].strip())
        if len(s.strip()) > 1:
            startSymbol = s.strip()[0]

    return (nonterminals, startSymbol)


def getTerminals():
    while (fin.readline().strip() != "Terminals:"):
        pass

    terminals = []

    while 1:
        s = fin.readline()
        if s.strip() == "End":
            break
        terminals.append(s.strip())

    return terminals


def getProductions():
    productions = dict()

    while (fin.readline().strip() != "Productions:"):
        pass

    while 1:
        s = fin.readline()
        if s.strip() == "End":
            break

        currentProduction = s.split()

        if currentProduction[0] not in productions:
            productions[currentProduction[0]] = []

        if currentProduction[1] == 'lambda':
            productions[currentProduction[0]].append("")
        else:
            productions[currentProduction[0]].append(currentProduction[1])

    return productions


def getQueries():
    queries = []

    while (fin.readline().strip() != "Queries:"):
        pass

    while 1:
        s = fin.readline()
        if s.strip() == "End":
            break
        queries.append(s.strip())

    return queries


def terminal(word):
    for letter in word:
        if letter in nonterminals:
            return 0
    return 1


def getNumberOfTerminals(word, terminals):
    cnt = 0
    for letter in word:
        if letter in terminals:
            cnt += 1

    return cnt


def solveQuery(terminals, nonterminals, startSymbol, productions, word):
    Q = []
    heapq.heappush(Q, (0, startSymbol))

    while len(Q) > 0 and getNumberOfTerminals(Q[0][1], terminals) <= len(word):
        currentWord = heapq.heappop(Q)[1]
        if currentWord == word and terminal(word):
            print("The word \"{}\" can be generated by the CFG".format(word), file=fout)
            return

        if not terminal(currentWord):
            for i in range(len(currentWord)):
                if currentWord[i] in nonterminals:
                    for prod in productions[currentWord[i]]:
                        newWord = currentWord[:i] + prod + currentWord[i + 1:]
                        heapq.heappush(Q, (getNumberOfTerminals(newWord, terminals), newWord))

    print("The word \"{}\" cannot be generated by the CFG".format(word), file=fout)


nonterminals, startSymbol = getNonterminals()
print(nonterminals)

print(startSymbol)

terminals = getTerminals()

print(terminals)

productions = getProductions()

print(productions)

queries = getQueries()

print(queries)

for word in queries:
    solveQuery(terminals, nonterminals, startSymbol, productions, word)

fin.close()
fout.close()
